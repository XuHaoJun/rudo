# Chez Scheme Cross-Platform Survey Results

This document summarizes an investigation into the Chez Scheme codebase (`learn-projects/ChezScheme`), specifically analyzing its approaches to cross-platform challenges relevant to `rudo-gc` (Stack/Register scanning, Memory Allocation, Threading).

## 1. Stack & Register Management

### A. Stack Bounds Detection
**Findings:**
Chez Scheme does **not** rely on the OS stack for running Scheme code. Instead, it implements a "Spaghetti Stack" model where stack frames are allocated in heap segments managed by the runtime.
-   **Implementation:** `S_reset_scheme_stack` (in `c/schsig.c` and `c/thread.c`) allocates new stack segments.
-   **OS Stack Usage:** The OS stack is only used for the C kernel and FFI calls. Scheme continuations are first-class objects on the heap.
-   **Implication for rudo-gc:** Chez Scheme avoids the "Stack Bounds Detection" problem entirely for the mutator by not using the OS stack. This is a radical architectural difference. `rudo-gc`, being a library for Rust (which uses the OS stack), cannot directly copy this approach without imposing a custom stack model on its users.

### B. Register Spilling
**Findings:**
Chez Scheme handles register saving via its compiler backends (e.g., `s/x86_64.ss`, `s/arm64.ss`) which generate code to save registers into the Thread Context (`tc`) or stack frames during context switches or GC safepoints.
-   **Mechanism:** It does not use `setjmp/longjmp` for the mutator's context saving in the same way BDWGC does. It uses explicit, precise register maps generated by the compiler.
-   **C Kernel:** For the C runtime, it relies on standard C ABI preservation.

## 2. Low-level Memory Allocation

### A. Windows `VirtualAlloc` & Page Size
**Findings:**
Chez Scheme uses `VirtualAlloc` for large memory chunks (segments) on Windows.
-   **File:** `c/segment.c`
-   **Implementation:**
    ```c
    // c/segment.c
    if ((uptr)bytes < S_pagesize) {
        addr = malloc(bytes); // Use malloc for small allocs
    } else {
        // Use VirtualAlloc for large allocs
        uptr n = S_pagesize - 1; 
        iptr p_bytes = (iptr)(((uptr)bytes + n) & ~n); // Align to S_pagesize
        addr = VirtualAlloc((void *)0, (SIZE_T)p_bytes, MEM_COMMIT, perm);
    }
    ```
-   **Page Size Definition:** On Windows, `S_getpagesize()` (in `c/windows.c`) calls `GetSystemInfo` and returns `si.dwPageSize` (typically **4KB**), *not* `dwAllocationGranularity` (64KB).
    ```c
    // c/windows.c
    INT S_getpagesize(void) {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        return si.dwPageSize;
    }
    ```
-   **Analysis:** Chez Scheme requests 4KB-aligned sizes from `VirtualAlloc`. Since `VirtualAlloc` (when `lpAddress` is NULL) always allocates at 64KB-aligned base addresses, this works but implies that `rudo-gc`'s concern about explicitly aligning to 64KB is handled implicitly by the OS for new allocations. However, `rudo-gc` should be aware that requesting 4KB consumes 64KB of address space.

## 3. Multi-threading & Coordination

### A. Thread Suspension
**Findings:**
Chez Scheme uses **Cooperative Suspension**, avoiding the problematic `SuspendThread` API on Windows.
-   **Mechanism:** Threads periodically check a "trap" flag in their Thread Context (`TRAP(tc)`).
-   **Trigger:** When GC is needed, the initiating thread sets the trap flag for other threads.
-   **Waiting:** Threads use Condition Variables (`SleepConditionVariableCS` on Windows, `pthread_cond_timedwait` on Unix) to wait while suspended.
-   **File:** `c/thread.c`
-   **Implication for rudo-gc:** This confirms that reliable cross-platform suspension on Windows is best achieved cooperatively. If `rudo-gc` requires preemptive suspension, it cannot follow Chez Scheme's example here.

## Summary of Key Takeaways for rudo-gc

| Feature | Chez Scheme Approach | Applicability to rudo-gc |
| :--- | :--- | :--- |
| **Stack Layout** | Heap-allocated "Spaghetti Stacks" | **Low**. `rudo-gc` manages Rust's OS stack. |
| **Stack Bounds** | Irrelevant (OS stack not used for mutator) | **None**. `rudo-gc` must solve this via OS APIs. |
| **Allocation** | `VirtualAlloc` aligned to `dwPageSize` (4KB) | **Medium**. Confirms 4KB alignment is valid for `VirtualAlloc` size, but beware address space fragmentation. |
| **Suspension** | Cooperative (`TRAP` checks) | **High** (if cooperative is acceptable). Avoids `SuspendThread` complexity. |
