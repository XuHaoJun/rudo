//! Derive macro for the `Trace` trait.
//!
//! This crate provides a procedural macro to automatically implement the `Trace` trait
//! for custom types, enabling them to be stored in `Gc<T>` smart pointers.
//!
//! # Usage
//!
//! ```ignore
//! use rudo_gc::{Gc, Trace};
//!
//! #[derive(Trace)]
//! struct MyStruct {
//!     value: i32,
//!     child: Option<Gc<MyStruct>>,
//! }
//! ```

use proc_macro2::TokenStream;
use quote::{format_ident, quote, quote_spanned};
use syn::{
    parse_macro_input, parse_quote, spanned::Spanned, Data, DeriveInput, Fields, GenericParam,
    Generics, Ident, Index, Path,
};

/// Derive the `Trace` trait for a struct or enum.
///
/// All fields that contain `Gc<T>` (directly or indirectly) will be
/// automatically traced during garbage collection.
///
/// # Examples
///
/// ```ignore
/// use rudo_gc::{Gc, Trace};
///
/// #[derive(Trace)]
/// struct Node {
///     value: i32,           // Primitive, no tracing needed
///     left: Option<Gc<Node>>,  // Traced
///     right: Option<Gc<Node>>, // Traced
/// }
/// ```
///
/// # Supported Types
///
/// - Structs with named fields
/// - Structs with tuple fields
/// - Unit structs
/// - Enums with any variant type
/// - Generic types (with `T: Trace` bounds added automatically)
#[proc_macro_derive(Trace, attributes(rudo_gc))]
pub fn derive_trace(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let mut rudo_gc: Path = parse_quote!(::rudo_gc);

    // Look for `crate` argument in attributes
    for attr in &input.attrs {
        if !attr.path().is_ident("rudo_gc") {
            continue;
        }

        let result = attr.parse_nested_meta(|meta| {
            if meta.path.is_ident("crate") {
                rudo_gc = meta.value()?.parse()?;
                Ok(())
            } else {
                Err(meta.error("unsupported attribute"))
            }
        });

        if let Err(err) = result {
            return err.into_compile_error().into();
        }
    }

    // Name of the type being implemented
    let name = &input.ident;

    // Generic parameters of the type being implemented
    let generics = add_trait_bounds(&rudo_gc, input.generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    // Generate the trace implementation
    let trace_body = generate_trace_body(&rudo_gc, name, &input.data);

    let generated = quote! {
        // SAFETY: This implementation is generated by the derive macro and
        // correctly traces all Gc fields in the structure.
        unsafe impl #impl_generics #rudo_gc::Trace for #name #ty_generics #where_clause {
            #[inline]
            fn trace(&self, visitor: &mut impl #rudo_gc::Visitor) {
                #trace_body
            }
        }
    };

    generated.into()
}

/// Add `T: Trace + 'static` bounds to all generic type parameters.
fn add_trait_bounds(rudo_gc: &Path, mut generics: Generics) -> Generics {
    for param in &mut generics.params {
        if let GenericParam::Type(ref mut type_param) = *param {
            let has_trace = type_param.bounds.iter().any(|b| {
                if let syn::TypeParamBound::Trait(t) = b {
                    t.path.segments.last().is_some_and(|s| s.ident == "Trace")
                } else {
                    false
                }
            });
            let has_static = type_param.bounds.iter().any(|b| {
                if let syn::TypeParamBound::Lifetime(l) = b {
                    l.ident == "static"
                } else {
                    false
                }
            });

            if !has_trace {
                type_param.bounds.push(parse_quote!(#rudo_gc::Trace));
            }
            if !has_static {
                type_param.bounds.push(parse_quote!('static));
            }
        }
    }
    generics
}

/// Generate the body of the `trace` method for the given data type.
fn generate_trace_body(rudo_gc: &Path, name: &Ident, data: &Data) -> TokenStream {
    match data {
        Data::Struct(data) => generate_struct_trace(rudo_gc, &data.fields),
        Data::Enum(data) => generate_enum_trace(rudo_gc, name, data),
        Data::Union(u) => {
            quote_spanned! {
                u.union_token.span => compile_error!("`Trace` must be manually implemented for unions");
            }
        }
    }
}

/// Generate trace calls for struct fields.
fn generate_struct_trace(rudo_gc: &Path, fields: &Fields) -> TokenStream {
    match fields {
        Fields::Named(f) => {
            let trace_calls = f.named.iter().map(|field| {
                let name = &field.ident;
                quote_spanned! {field.span() =>
                    #rudo_gc::Trace::trace(&self.#name, visitor);
                }
            });
            quote! { #(#trace_calls)* }
        }
        Fields::Unnamed(f) => {
            let trace_calls = f.unnamed.iter().enumerate().map(|(i, field)| {
                let index = Index::from(i);
                quote_spanned! {field.span() =>
                    #rudo_gc::Trace::trace(&self.#index, visitor);
                }
            });
            quote! { #(#trace_calls)* }
        }
        Fields::Unit => quote! {},
    }
}

/// Generate trace calls for enum variants.
fn generate_enum_trace(rudo_gc: &Path, name: &Ident, data: &syn::DataEnum) -> TokenStream {
    let match_arms = data.variants.iter().map(|variant| {
        let var_name = &variant.ident;
        match &variant.fields {
            Fields::Named(f) => {
                let field_names: Vec<_> = f
                    .named
                    .iter()
                    .enumerate()
                    .map(|(i, _)| format_ident!("field{}", i))
                    .collect();
                let field_idents: Vec<_> =
                    f.named.iter().map(|f| f.ident.as_ref().unwrap()).collect();
                let trace_calls = field_names.iter().map(|field| {
                    quote! { #rudo_gc::Trace::trace(#field, visitor); }
                });

                quote! {
                    #name::#var_name { #(#field_idents: #field_names),* } => {
                        #(#trace_calls)*
                    }
                }
            }
            Fields::Unnamed(f) => {
                let field_names: Vec<_> = (0..f.unnamed.len())
                    .map(|i| format_ident!("field{}", i))
                    .collect();
                let trace_calls = field_names.iter().map(|field| {
                    quote! { #rudo_gc::Trace::trace(#field, visitor); }
                });

                quote! {
                    #name::#var_name(#(#field_names),*) => {
                        #(#trace_calls)*
                    }
                }
            }
            Fields::Unit => {
                quote! {
                    #name::#var_name => {}
                }
            }
        }
    });

    quote! {
        match self {
            #(#match_arms)*
        }
    }
}
